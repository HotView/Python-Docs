<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.12" name="generator"/>
<title>OpenCV: Optical Flow Algorithms</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script src="../../jquery.js" type="text/javascript"></script>
<script src="../../dynsections.js" type="text/javascript"></script>
<script src="../../tutorial-utils.js" type="text/javascript"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script src="../../search/searchdata.js" type="text/javascript"></script>
<script src="../../search/search.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js" type="text/javascript"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellpadding="0" cellspacing="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
    <span id="projectnumber">4.0.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script src="../../menudata.js" type="text/javascript"></script>
<script src="../../menu.js" type="text/javascript"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Optical Flow Algorithms</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d4d/classcv_1_1optflow_1_1DualTVL1OpticalFlow.html">cv::optflow::DualTVL1OpticalFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">"Dual TV L1" Optical Flow <a class="el" href="../../d3/d46/classcv_1_1Algorithm.html" title="This is a base class for all more or less complex algorithms in OpenCV. ">Algorithm</a>.  <a href="../../dc/d4d/classcv_1_1optflow_1_1DualTVL1OpticalFlow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dba/classcv_1_1optflow_1_1GPCDetails.html">cv::optflow::GPCDetails</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfe/classcv_1_1optflow_1_1GPCForest.html">cv::optflow::GPCForest&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">cv::optflow::GPCMatchingParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class encapsulating matching parameters.  <a href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dfd/structcv_1_1optflow_1_1GPCPatchDescriptor.html">cv::optflow::GPCPatchDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d6a/structcv_1_1optflow_1_1GPCPatchSample.html">cv::optflow::GPCPatchSample</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcc/structcv_1_1optflow_1_1GPCTrainingParams.html">cv::optflow::GPCTrainingParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class encapsulating training parameters.  <a href="../../d1/dcc/structcv_1_1optflow_1_1GPCTrainingParams.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d49/classcv_1_1optflow_1_1GPCTrainingSamples.html">cv::optflow::GPCTrainingSamples</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class encapsulating training samples.  <a href="../../d5/d49/classcv_1_1optflow_1_1GPCTrainingSamples.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d4d/classcv_1_1optflow_1_1GPCTree.html">cv::optflow::GPCTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class for individual tree.  <a href="../../d4/d4d/classcv_1_1optflow_1_1GPCTree.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da2/classcv_1_1optflow_1_1OpticalFlowPCAFlow.html">cv::optflow::OpticalFlowPCAFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">PCAFlow algorithm.  <a href="../../d1/da2/classcv_1_1optflow_1_1OpticalFlowPCAFlow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d5e/classcv_1_1optflow_1_1PCAPrior.html">cv::optflow::PCAPrior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">This class can be used for imposing a learned prior on the resulting optical flow. Solution will be regularized according to this prior. You need to generate appropriate prior file with "learn_prior.py" script beforehand.  <a href="../../d5/d5e/classcv_1_1optflow_1_1PCAPrior.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaae8114ca8607c4a6f7735b313fe9a342"><td align="right" class="memItemLeft" valign="top">typedef std::vector&lt; <a class="el" href="../../d4/d6a/structcv_1_1optflow_1_1GPCPatchSample.html">GPCPatchSample</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gaae8114ca8607c4a6f7735b313fe9a342">cv::optflow::GPCSamplesVector</a></td></tr>
<tr class="separator:gaae8114ca8607c4a6f7735b313fe9a342"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa42b40f18dde15651b35c2666ac6824d"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gaa42b40f18dde15651b35c2666ac6824d">cv::optflow::GPCDescType</a> { <br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggaa42b40f18dde15651b35c2666ac6824da2ca1454e5a45e1faac62237cad32b479">cv::optflow::GPC_DESCRIPTOR_DCT</a> = 0, 
<br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggaa42b40f18dde15651b35c2666ac6824da363ac25bbb8fad970bf2efbdcccab11b">cv::optflow::GPC_DESCRIPTOR_WHT</a>
<br/>
 }<tr class="memdesc:gaa42b40f18dde15651b35c2666ac6824d"><td class="mdescLeft"> </td><td class="mdescRight">Descriptor types for the Global Patch Collider.  <a href="../../d2/d84/group__optflow.html#gaa42b40f18dde15651b35c2666ac6824d">More...</a><br/></td></tr>
</td></tr>
<tr class="separator:gaa42b40f18dde15651b35c2666ac6824d"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9b841df1ad43ae7ea06fb3cdd6408db7"><td align="right" class="memItemLeft" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga9b841df1ad43ae7ea06fb3cdd6408db7">cv::motempl::calcGlobalOrientation</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> orientation, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> mask, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> mhi, double timestamp, double duration)</td></tr>
<tr class="memdesc:ga9b841df1ad43ae7ea06fb3cdd6408db7"><td class="mdescLeft"> </td><td class="mdescRight">Calculates a global motion orientation in a selected region.  <a href="../../d2/d84/group__optflow.html#ga9b841df1ad43ae7ea06fb3cdd6408db7">More...</a><br/></td></tr>
<tr class="separator:ga9b841df1ad43ae7ea06fb3cdd6408db7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf81cb3d2e60299558df0e4d6c0e059a7"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gaf81cb3d2e60299558df0e4d6c0e059a7">cv::motempl::calcMotionGradient</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> mhi, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> mask, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> orientation, double delta1, double delta2, int apertureSize=3)</td></tr>
<tr class="memdesc:gaf81cb3d2e60299558df0e4d6c0e059a7"><td class="mdescLeft"> </td><td class="mdescRight">Calculates a gradient orientation of a motion history image.  <a href="../../d2/d84/group__optflow.html#gaf81cb3d2e60299558df0e4d6c0e059a7">More...</a><br/></td></tr>
<tr class="separator:gaf81cb3d2e60299558df0e4d6c0e059a7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga370e4f91055a5ae14a0db71850b2f788"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga370e4f91055a5ae14a0db71850b2f788">cv::optflow::calcOpticalFlowSF</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> from, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> to, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> flow, int layers, int averaging_block_size, int max_flow)</td></tr>
<tr class="separator:ga370e4f91055a5ae14a0db71850b2f788"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf23c367519903ed2384e9532e43c7032"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gaf23c367519903ed2384e9532e43c7032">cv::optflow::calcOpticalFlowSF</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> from, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> to, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> flow, int layers, int averaging_block_size, int max_flow, double sigma_dist, double sigma_color, int postprocess_window, double sigma_dist_fix, double sigma_color_fix, double occ_thr, int upscale_averaging_radius, double upscale_sigma_dist, double upscale_sigma_color, double speed_up_thr)</td></tr>
<tr class="memdesc:gaf23c367519903ed2384e9532e43c7032"><td class="mdescLeft"> </td><td class="mdescRight">Calculate an optical flow using "SimpleFlow" algorithm.  <a href="../../d2/d84/group__optflow.html#gaf23c367519903ed2384e9532e43c7032">More...</a><br/></td></tr>
<tr class="separator:gaf23c367519903ed2384e9532e43c7032"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad6aa63f2703202806fe18dc1353b5f4b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gad6aa63f2703202806fe18dc1353b5f4b">cv::optflow::calcOpticalFlowSparseToDense</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> from, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> to, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> flow, int grid_step=8, int k=128, float sigma=0.05f, bool use_post_proc=true, float fgs_lambda=500.0f, float fgs_sigma=1.5f)</td></tr>
<tr class="memdesc:gad6aa63f2703202806fe18dc1353b5f4b"><td class="mdescLeft"> </td><td class="mdescRight">Fast dense optical flow based on PyrLK sparse matches interpolation.  <a href="../../d2/d84/group__optflow.html#gad6aa63f2703202806fe18dc1353b5f4b">More...</a><br/></td></tr>
<tr class="separator:gad6aa63f2703202806fe18dc1353b5f4b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5e735547610172695cb0b39495af9d6d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga5e735547610172695cb0b39495af9d6d">cv::optflow::createOptFlow_DeepFlow</a> ()</td></tr>
<tr class="memdesc:ga5e735547610172695cb0b39495af9d6d"><td class="mdescLeft"> </td><td class="mdescRight">DeepFlow optical flow algorithm implementation.  <a href="../../d2/d84/group__optflow.html#ga5e735547610172695cb0b39495af9d6d">More...</a><br/></td></tr>
<tr class="separator:ga5e735547610172695cb0b39495af9d6d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga132098d4d6e74b96c715bb9c451a1d8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../dc/d4d/classcv_1_1optflow_1_1DualTVL1OpticalFlow.html">DualTVL1OpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga132098d4d6e74b96c715bb9c451a1d8f">cv::optflow::createOptFlow_DualTVL1</a> ()</td></tr>
<tr class="memdesc:ga132098d4d6e74b96c715bb9c451a1d8f"><td class="mdescLeft"> </td><td class="mdescRight">Creates instance of <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">cv::DenseOpticalFlow</a>.  <a href="../../d2/d84/group__optflow.html#ga132098d4d6e74b96c715bb9c451a1d8f">More...</a><br/></td></tr>
<tr class="separator:ga132098d4d6e74b96c715bb9c451a1d8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadd1519b8b360c101de0a2d3d3ca5f0e1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gadd1519b8b360c101de0a2d3d3ca5f0e1">cv::optflow::createOptFlow_Farneback</a> ()</td></tr>
<tr class="memdesc:gadd1519b8b360c101de0a2d3d3ca5f0e1"><td class="mdescLeft"> </td><td class="mdescRight">Additional interface to the Farneback's algorithm - <a class="el" href="../../dc/d6b/group__video__track.html#ga5d10ebbd59fe09c5f650289ec0ece5af" title="Computes a dense optical flow using the Gunnar Farneback's algorithm. ">calcOpticalFlowFarneback()</a>  <a href="../../d2/d84/group__optflow.html#gadd1519b8b360c101de0a2d3d3ca5f0e1">More...</a><br/></td></tr>
<tr class="separator:gadd1519b8b360c101de0a2d3d3ca5f0e1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabbf0942f6ab840dcb1c10273b02507f0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gabbf0942f6ab840dcb1c10273b02507f0">cv::optflow::createOptFlow_PCAFlow</a> ()</td></tr>
<tr class="memdesc:gabbf0942f6ab840dcb1c10273b02507f0"><td class="mdescLeft"> </td><td class="mdescRight">Creates an instance of PCAFlow.  <a href="../../d2/d84/group__optflow.html#gabbf0942f6ab840dcb1c10273b02507f0">More...</a><br/></td></tr>
<tr class="separator:gabbf0942f6ab840dcb1c10273b02507f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab3fd0cd6d32cb7cfa169cb72e804d0b4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gab3fd0cd6d32cb7cfa169cb72e804d0b4">cv::optflow::createOptFlow_SimpleFlow</a> ()</td></tr>
<tr class="memdesc:gab3fd0cd6d32cb7cfa169cb72e804d0b4"><td class="mdescLeft"> </td><td class="mdescRight">Additional interface to the SimpleFlow algorithm - <a class="el" href="../../d2/d84/group__optflow.html#ga370e4f91055a5ae14a0db71850b2f788">calcOpticalFlowSF()</a>  <a href="../../d2/d84/group__optflow.html#gab3fd0cd6d32cb7cfa169cb72e804d0b4">More...</a><br/></td></tr>
<tr class="separator:gab3fd0cd6d32cb7cfa169cb72e804d0b4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae7bcbdec27f2006dde666c5f6c6e232d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gae7bcbdec27f2006dde666c5f6c6e232d">cv::optflow::createOptFlow_SparseToDense</a> ()</td></tr>
<tr class="memdesc:gae7bcbdec27f2006dde666c5f6c6e232d"><td class="mdescLeft"> </td><td class="mdescRight">Additional interface to the SparseToDenseFlow algorithm - <a class="el" href="../../d2/d84/group__optflow.html#gad6aa63f2703202806fe18dc1353b5f4b" title="Fast dense optical flow based on PyrLK sparse matches interpolation. ">calcOpticalFlowSparseToDense()</a>  <a href="../../d2/d84/group__optflow.html#gae7bcbdec27f2006dde666c5f6c6e232d">More...</a><br/></td></tr>
<tr class="separator:gae7bcbdec27f2006dde666c5f6c6e232d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga91c50d0cd4b35a72f3850f87fddec2cb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga91c50d0cd4b35a72f3850f87fddec2cb">cv::optflow::GPCForest&lt; T &gt;::findCorrespondences</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> imgFrom, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> imgTo, std::vector&lt; std::pair&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga0f70b52f0c0b119f7ed2448ffebdc144">Point2i</a>, <a class="el" href="../../dc/d84/group__core__basic.html#ga0f70b52f0c0b119f7ed2448ffebdc144">Point2i</a> &gt; &gt; &amp;corr, const <a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">GPCMatchingParams</a> params=<a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">GPCMatchingParams</a>()) const</td></tr>
<tr class="memdesc:ga91c50d0cd4b35a72f3850f87fddec2cb"><td class="mdescLeft"> </td><td class="mdescRight">Find correspondences between two images.  <a href="#ga91c50d0cd4b35a72f3850f87fddec2cb">More...</a><br/></td></tr>
<tr class="separator:ga91c50d0cd4b35a72f3850f87fddec2cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9eea50c233a0a6d7fecdd2c66821eed5"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga9eea50c233a0a6d7fecdd2c66821eed5">cv::motempl::segmentMotion</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> mhi, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> segmask, std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga11d95de507098e90bad732b9345402e8">Rect</a> &gt; &amp;boundingRects, double timestamp, double segThresh)</td></tr>
<tr class="memdesc:ga9eea50c233a0a6d7fecdd2c66821eed5"><td class="mdescLeft"> </td><td class="mdescRight">Splits a motion history image into a few parts corresponding to separate independent motions (for example, left hand, right hand).  <a href="../../d2/d84/group__optflow.html#ga9eea50c233a0a6d7fecdd2c66821eed5">More...</a><br/></td></tr>
<tr class="separator:ga9eea50c233a0a6d7fecdd2c66821eed5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9c60ca58707e508be624e21da1273026"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga9c60ca58707e508be624e21da1273026">cv::motempl::updateMotionHistory</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> silhouette, <a class="el" href="../../dc/d84/group__core__basic.html#gaf77c9a14ef956c50c1efd4547f444e63">InputOutputArray</a> mhi, double timestamp, double duration)</td></tr>
<tr class="memdesc:ga9c60ca58707e508be624e21da1273026"><td class="mdescLeft"> </td><td class="mdescRight">Updates the motion history image by a moving silhouette.  <a href="../../d2/d84/group__optflow.html#ga9c60ca58707e508be624e21da1273026">More...</a><br/></td></tr>
<tr class="separator:ga9c60ca58707e508be624e21da1273026"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Dense optical flow algorithms compute motion for each point:</p>
<ul>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga370e4f91055a5ae14a0db71850b2f788">cv::optflow::calcOpticalFlowSF</a></li>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga5e735547610172695cb0b39495af9d6d" title="DeepFlow optical flow algorithm implementation. ">cv::optflow::createOptFlow_DeepFlow</a></li>
</ul>
<p>Motion templates is alternative technique for detecting motion and computing its direction. See samples/motempl.py.</p>
<ul>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga9c60ca58707e508be624e21da1273026" title="Updates the motion history image by a moving silhouette. ">cv::motempl::updateMotionHistory</a></li>
<li><a class="el" href="../../d2/d84/group__optflow.html#gaf81cb3d2e60299558df0e4d6c0e059a7" title="Calculates a gradient orientation of a motion history image. ">cv::motempl::calcMotionGradient</a></li>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga9b841df1ad43ae7ea06fb3cdd6408db7" title="Calculates a global motion orientation in a selected region. ">cv::motempl::calcGlobalOrientation</a></li>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga9eea50c233a0a6d7fecdd2c66821eed5" title="Splits a motion history image into a few parts corresponding to separate independent motions (for exa...">cv::motempl::segmentMotion</a></li>
</ul>
<p>Functions reading and writing .flo files in "Middlebury" format, see: <a href="http://vision.middlebury.edu/flow/code/flow-code/README.txt">http://vision.middlebury.edu/flow/code/flow-code/README.txt</a></p>
<ul>
<li>cv::optflow::readOpticalFlow</li>
<li>cv::optflow::writeOpticalFlow </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaae8114ca8607c4a6f7735b313fe9a342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae8114ca8607c4a6f7735b313fe9a342">§ </a></span>GPCSamplesVector</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="../../d4/d6a/structcv_1_1optflow_1_1GPCPatchSample.html">GPCPatchSample</a> &gt; <a class="el" href="../../d2/d84/group__optflow.html#gaae8114ca8607c4a6f7735b313fe9a342">cv::optflow::GPCSamplesVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa42b40f18dde15651b35c2666ac6824d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa42b40f18dde15651b35c2666ac6824d">§ </a></span>GPCDescType</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d2/d84/group__optflow.html#gaa42b40f18dde15651b35c2666ac6824d">cv::optflow::GPCDescType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descriptor types for the Global Patch Collider. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa42b40f18dde15651b35c2666ac6824da2ca1454e5a45e1faac62237cad32b479"></a>GPC_DESCRIPTOR_DCT <div class="python_language">Python: cv.optflow.GPC_DESCRIPTOR_DCT</div></td><td class="fielddoc"><p>Better quality but slow. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa42b40f18dde15651b35c2666ac6824da363ac25bbb8fad970bf2efbdcccab11b"></a>GPC_DESCRIPTOR_WHT <div class="python_language">Python: cv.optflow.GPC_DESCRIPTOR_WHT</div></td><td class="fielddoc"><p>Worse quality but much faster. </p>
</td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9b841df1ad43ae7ea06fb3cdd6408db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b841df1ad43ae7ea06fb3cdd6408db7">§ </a></span>calcGlobalOrientation()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cv::motempl::calcGlobalOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>duration</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>retval</td><td>=</td><td>cv.motempl.calcGlobalOrientation(</td><td class="paramname">orientation, mask, mhi, timestamp, duration</td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Calculates a global motion orientation in a selected region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>Motion gradient orientation image calculated by the function calcMotionGradient </td></tr>
    <tr><td class="paramname">mask</td><td>Mask image. It may be a conjunction of a valid gradient mask, also calculated by calcMotionGradient , and the mask of a region whose direction needs to be calculated. </td></tr>
    <tr><td class="paramname">mhi</td><td>Motion history image calculated by updateMotionHistory . </td></tr>
    <tr><td class="paramname">timestamp</td><td>Timestamp passed to updateMotionHistory . </td></tr>
    <tr><td class="paramname">duration</td><td>Maximum duration of a motion track in milliseconds, passed to updateMotionHistory</td></tr>
  </table>
  </dd>
</dl>
<p>The function calculates an average motion direction in the selected region and returns the angle between 0 degrees and 360 degrees. The average direction is computed from the weighted orientation histogram, where a recent motion has a larger weight and the motion occurred in the past has a smaller weight, as recorded in mhi . </p>
</div>
</div>
<a id="gaf81cb3d2e60299558df0e4d6c0e059a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81cb3d2e60299558df0e4d6c0e059a7">§ </a></span>calcMotionGradient()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::motempl::calcMotionGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>delta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>delta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>apertureSize</em> = <code>3</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>mask, orientation</td><td>=</td><td>cv.motempl.calcMotionGradient(</td><td class="paramname">mhi, delta1, delta2[, mask[, orientation[, apertureSize]]]</td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Calculates a gradient orientation of a motion history image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhi</td><td>Motion history single-channel floating-point image. </td></tr>
    <tr><td class="paramname">mask</td><td>Output mask image that has the type CV_8UC1 and the same size as mhi . Its non-zero elements mark pixels where the motion gradient data is correct. </td></tr>
    <tr><td class="paramname">orientation</td><td>Output motion gradient orientation image that has the same type and the same size as mhi . Each pixel of the image is a motion orientation, from 0 to 360 degrees. </td></tr>
    <tr><td class="paramname">delta1</td><td>Minimal (or maximal) allowed difference between mhi values within a pixel neighborhood. </td></tr>
    <tr><td class="paramname">delta2</td><td>Maximal (or minimal) allowed difference between mhi values within a pixel neighborhood. That is, the function finds the minimum ( \(m(x,y)\) ) and maximum ( \(M(x,y)\) ) mhi values over \(3 \times 3\) neighborhood of each pixel and marks the motion orientation at \((x, y)\) as valid only if <p class="formulaDsp">
\[\min ( \texttt{delta1} , \texttt{delta2} ) \le M(x,y)-m(x,y) \le \max ( \texttt{delta1} , \texttt{delta2} ).\]
</p>
 </td></tr>
    <tr><td class="paramname">apertureSize</td><td>Aperture size of the Sobel operator.</td></tr>
  </table>
  </dd>
</dl>
<p>The function calculates a gradient orientation at each pixel \((x, y)\) as:</p>
<p class="formulaDsp">
\[\texttt{orientation} (x,y)= \arctan{\frac{d\texttt{mhi}/dy}{d\texttt{mhi}/dx}}\]
</p>
<p>In fact, fastAtan2 and phase are used so that the computed angle is measured in degrees and covers the full range 0..360. Also, the mask is filled to indicate pixels where the computed angle is valid.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>(Python) An example on how to perform a motion template technique can be found at opencv_source_code/samples/python2/motempl.py </li>
</ul>
</dd></dl>
</div>
</div>
<a id="ga370e4f91055a5ae14a0db71850b2f788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370e4f91055a5ae14a0db71850b2f788">§ </a></span>calcOpticalFlowSF() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::optflow::calcOpticalFlowSF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>averaging_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>max_flow</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>flow</td><td>=</td><td>cv.optflow.calcOpticalFlowSF(</td><td class="paramname">from, to, layers, averaging_block_size, max_flow[, flow]</td><td>)</td></tr><tr><td style="width: 20px;"></td><td>flow</td><td>=</td><td>cv.optflow.calcOpticalFlowSF(</td><td class="paramname">from, to, layers, averaging_block_size, max_flow, sigma_dist, sigma_color, postprocess_window, sigma_dist_fix, sigma_color_fix, occ_thr, upscale_averaging_radius, upscale_sigma_dist, upscale_sigma_color, speed_up_thr[, flow]</td><td>)</td></tr></table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
</div>
</div>
<a id="gaf23c367519903ed2384e9532e43c7032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf23c367519903ed2384e9532e43c7032">§ </a></span>calcOpticalFlowSF() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::optflow::calcOpticalFlowSF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>averaging_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>max_flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>sigma_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>sigma_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>postprocess_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>sigma_dist_fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>sigma_color_fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>occ_thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>upscale_averaging_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>upscale_sigma_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>upscale_sigma_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>speed_up_thr</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>flow</td><td>=</td><td>cv.optflow.calcOpticalFlowSF(</td><td class="paramname">from, to, layers, averaging_block_size, max_flow[, flow]</td><td>)</td></tr><tr><td style="width: 20px;"></td><td>flow</td><td>=</td><td>cv.optflow.calcOpticalFlowSF(</td><td class="paramname">from, to, layers, averaging_block_size, max_flow, sigma_dist, sigma_color, postprocess_window, sigma_dist_fix, sigma_color_fix, occ_thr, upscale_averaging_radius, upscale_sigma_dist, upscale_sigma_color, speed_up_thr[, flow]</td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Calculate an optical flow using "SimpleFlow" algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>First 8-bit 3-channel image. </td></tr>
    <tr><td class="paramname">to</td><td>Second 8-bit 3-channel image of the same size as prev </td></tr>
    <tr><td class="paramname">flow</td><td>computed flow image that has the same size as prev and type CV_32FC2 </td></tr>
    <tr><td class="paramname">layers</td><td>Number of layers </td></tr>
    <tr><td class="paramname">averaging_block_size</td><td>Size of block through which we sum up when calculate cost function for pixel </td></tr>
    <tr><td class="paramname">max_flow</td><td>maximal flow that we search at each level </td></tr>
    <tr><td class="paramname">sigma_dist</td><td>vector smooth spatial sigma parameter </td></tr>
    <tr><td class="paramname">sigma_color</td><td>vector smooth color sigma parameter </td></tr>
    <tr><td class="paramname">postprocess_window</td><td>window size for postprocess cross bilateral filter </td></tr>
    <tr><td class="paramname">sigma_dist_fix</td><td>spatial sigma for postprocess cross bilateralf filter </td></tr>
    <tr><td class="paramname">sigma_color_fix</td><td>color sigma for postprocess cross bilateral filter </td></tr>
    <tr><td class="paramname">occ_thr</td><td>threshold for detecting occlusions </td></tr>
    <tr><td class="paramname">upscale_averaging_radius</td><td>window size for bilateral upscale operation </td></tr>
    <tr><td class="paramname">upscale_sigma_dist</td><td>spatial sigma for bilateral upscale operation </td></tr>
    <tr><td class="paramname">upscale_sigma_color</td><td>color sigma for bilateral upscale operation </td></tr>
    <tr><td class="paramname">speed_up_thr</td><td>threshold to detect point with irregular flow - where flow should be recalculated after upscale</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="../../d0/de3/citelist.html#CITEREF_Tao2012">[189]</a> . And site of project - <a href="http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/">http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/</a>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>An example using the simpleFlow algorithm can be found at samples/simpleflow_demo.cpp </li>
</ul>
</dd></dl>
</div>
</div>
<a id="gad6aa63f2703202806fe18dc1353b5f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6aa63f2703202806fe18dc1353b5f4b">§ </a></span>calcOpticalFlowSparseToDense()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::optflow::calcOpticalFlowSparseToDense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>grid_step</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>k</em> = <code>128</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>sigma</em> = <code>0.05f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>use_post_proc</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>fgs_lambda</em> = <code>500.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>fgs_sigma</em> = <code>1.5f</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>flow</td><td>=</td><td>cv.optflow.calcOpticalFlowSparseToDense(</td><td class="paramname">from, to[, flow[, grid_step[, k[, sigma[, use_post_proc[, fgs_lambda[, fgs_sigma]]]]]]]</td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Fast dense optical flow based on PyrLK sparse matches interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>first 8-bit 3-channel or 1-channel image. </td></tr>
    <tr><td class="paramname">to</td><td>second 8-bit 3-channel or 1-channel image of the same size as from </td></tr>
    <tr><td class="paramname">flow</td><td>computed flow image that has the same size as from and CV_32FC2 type </td></tr>
    <tr><td class="paramname">grid_step</td><td>stride used in sparse match computation. Lower values usually result in higher quality but slow down the algorithm. </td></tr>
    <tr><td class="paramname">k</td><td>number of nearest-neighbor matches considered, when fitting a locally affine model. Lower values can make the algorithm noticeably faster at the cost of some quality degradation. </td></tr>
    <tr><td class="paramname">sigma</td><td>parameter defining how fast the weights decrease in the locally-weighted affine fitting. Higher values can help preserve fine details, lower values can help to get rid of the noise in the output flow. </td></tr>
    <tr><td class="paramname">use_post_proc</td><td>defines whether the <a class="el" href="../../da/d17/group__ximgproc__filters.html#gaf8673fe9147160ad96ac6053fac3c106" title="Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same...">ximgproc::fastGlobalSmootherFilter()</a> is used for post-processing after interpolation </td></tr>
    <tr><td class="paramname">fgs_lambda</td><td>see the respective parameter of the <a class="el" href="../../da/d17/group__ximgproc__filters.html#gaf8673fe9147160ad96ac6053fac3c106" title="Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same...">ximgproc::fastGlobalSmootherFilter()</a> </td></tr>
    <tr><td class="paramname">fgs_sigma</td><td>see the respective parameter of the <a class="el" href="../../da/d17/group__ximgproc__filters.html#gaf8673fe9147160ad96ac6053fac3c106" title="Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same...">ximgproc::fastGlobalSmootherFilter()</a> </td></tr>
  </table>
  </dd>
</dl>
</div>
</div>
<a id="ga5e735547610172695cb0b39495af9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e735547610172695cb0b39495af9d6d">§ </a></span>createOptFlow_DeepFlow()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_DeepFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>retval</td><td>=</td><td>cv.optflow.createOptFlow_DeepFlow(</td><td class="paramname"></td><td>)</td></tr></table>
</div><div class="memdoc">
<p>DeepFlow optical flow algorithm implementation. </p>
<p>The class implements the DeepFlow optical flow algorithm described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Weinzaepfel2013">[215]</a> . See also <a href="http://lear.inrialpes.fr/src/deepmatching/">http://lear.inrialpes.fr/src/deepmatching/</a> . Parameters - class fields - that may be modified after creating a class instance:</p><ul>
<li>member float alpha Smoothness assumption weight</li>
<li>member float delta Color constancy assumption weight</li>
<li>member float gamma Gradient constancy weight</li>
<li>member float sigma Gaussian smoothing parameter</li>
<li>member int minSize Minimal dimension of an image in the pyramid (next, smaller images in the pyramid are generated until one of the dimensions reaches this size)</li>
<li>member float downscaleFactor Scaling factor in the image pyramid (must be &lt; 1)</li>
<li>member int fixedPointIterations How many iterations on each level of the pyramid</li>
<li>member int sorIterations Iterations of Succesive Over-Relaxation (solver)</li>
<li>member float omega Relaxation factor in SOR </li>
</ul>
</div>
</div>
<a id="ga132098d4d6e74b96c715bb9c451a1d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga132098d4d6e74b96c715bb9c451a1d8f">§ </a></span>createOptFlow_DualTVL1()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../dc/d4d/classcv_1_1optflow_1_1DualTVL1OpticalFlow.html">DualTVL1OpticalFlow</a>&gt; cv::optflow::createOptFlow_DualTVL1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>retval</td><td>=</td><td>cv.optflow.createOptFlow_DualTVL1(</td><td class="paramname"></td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Creates instance of <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">cv::DenseOpticalFlow</a>. </p>
</div>
</div>
<a id="gadd1519b8b360c101de0a2d3d3ca5f0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd1519b8b360c101de0a2d3d3ca5f0e1">§ </a></span>createOptFlow_Farneback()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_Farneback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>retval</td><td>=</td><td>cv.optflow.createOptFlow_Farneback(</td><td class="paramname"></td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Additional interface to the Farneback's algorithm - <a class="el" href="../../dc/d6b/group__video__track.html#ga5d10ebbd59fe09c5f650289ec0ece5af" title="Computes a dense optical flow using the Gunnar Farneback's algorithm. ">calcOpticalFlowFarneback()</a> </p>
</div>
</div>
<a id="gabbf0942f6ab840dcb1c10273b02507f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbf0942f6ab840dcb1c10273b02507f0">§ </a></span>createOptFlow_PCAFlow()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_PCAFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>retval</td><td>=</td><td>cv.optflow.createOptFlow_PCAFlow(</td><td class="paramname"></td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Creates an instance of PCAFlow. </p>
</div>
</div>
<a id="gab3fd0cd6d32cb7cfa169cb72e804d0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3fd0cd6d32cb7cfa169cb72e804d0b4">§ </a></span>createOptFlow_SimpleFlow()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_SimpleFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>retval</td><td>=</td><td>cv.optflow.createOptFlow_SimpleFlow(</td><td class="paramname"></td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Additional interface to the SimpleFlow algorithm - <a class="el" href="../../d2/d84/group__optflow.html#ga370e4f91055a5ae14a0db71850b2f788">calcOpticalFlowSF()</a> </p>
</div>
</div>
<a id="gae7bcbdec27f2006dde666c5f6c6e232d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7bcbdec27f2006dde666c5f6c6e232d">§ </a></span>createOptFlow_SparseToDense()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_SparseToDense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>retval</td><td>=</td><td>cv.optflow.createOptFlow_SparseToDense(</td><td class="paramname"></td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Additional interface to the SparseToDenseFlow algorithm - <a class="el" href="../../d2/d84/group__optflow.html#gad6aa63f2703202806fe18dc1353b5f4b" title="Fast dense optical flow based on PyrLK sparse matches interpolation. ">calcOpticalFlowSparseToDense()</a> </p>
</div>
</div>
<a id="ga91c50d0cd4b35a72f3850f87fddec2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91c50d0cd4b35a72f3850f87fddec2cb">§ </a></span>findCorrespondences()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/dfe/classcv_1_1optflow_1_1GPCForest.html">cv::optflow::GPCForest</a>&lt; T &gt;::findCorrespondences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>imgFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>imgTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga0f70b52f0c0b119f7ed2448ffebdc144">Point2i</a>, <a class="el" href="../../dc/d84/group__core__basic.html#ga0f70b52f0c0b119f7ed2448ffebdc144">Point2i</a> &gt; &gt; &amp; </td>
          <td class="paramname"><em>corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">GPCMatchingParams</a> </td>
          <td class="paramname"><em>params</em> = <code><a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">GPCMatchingParams</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find correspondences between two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imgFrom</td><td>First image in a sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imgTo</td><td>Second image in a sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">corr</td><td>Output vector with pairs of corresponding points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Additional matching parameters for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>
</div>
</div>
<a id="ga9eea50c233a0a6d7fecdd2c66821eed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eea50c233a0a6d7fecdd2c66821eed5">§ </a></span>segmentMotion()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::motempl::segmentMotion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>segmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga11d95de507098e90bad732b9345402e8">Rect</a> &gt; &amp; </td>
          <td class="paramname"><em>boundingRects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>segThresh</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>segmask, boundingRects</td><td>=</td><td>cv.motempl.segmentMotion(</td><td class="paramname">mhi, timestamp, segThresh[, segmask]</td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Splits a motion history image into a few parts corresponding to separate independent motions (for example, left hand, right hand). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhi</td><td>Motion history image. </td></tr>
    <tr><td class="paramname">segmask</td><td>Image where the found mask should be stored, single-channel, 32-bit floating-point. </td></tr>
    <tr><td class="paramname">boundingRects</td><td>Vector containing ROIs of motion connected components. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Current time in milliseconds or other units. </td></tr>
    <tr><td class="paramname">segThresh</td><td>Segmentation threshold that is recommended to be equal to the interval between motion history "steps" or greater.</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds all of the motion segments and marks them in segmask with individual values (1,2,...). It also computes a vector with ROIs of motion connected components. After that the motion direction for every component can be calculated with calcGlobalOrientation using the extracted mask of the particular component. </p>
</div>
</div>
<a id="ga9c60ca58707e508be624e21da1273026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c60ca58707e508be624e21da1273026">§ </a></span>updateMotionHistory()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::motempl::updateMotionHistory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>silhouette</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaf77c9a14ef956c50c1efd4547f444e63">InputOutputArray</a> </td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>duration</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>mhi</td><td>=</td><td>cv.motempl.updateMotionHistory(</td><td class="paramname">silhouette, mhi, timestamp, duration</td><td>)</td></tr></table>
</div><div class="memdoc">
<p>Updates the motion history image by a moving silhouette. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silhouette</td><td>Silhouette mask that has non-zero pixels where the motion occurs. </td></tr>
    <tr><td class="paramname">mhi</td><td>Motion history image that is updated by the function (single-channel, 32-bit floating-point). </td></tr>
    <tr><td class="paramname">timestamp</td><td>Current time in milliseconds or other units. </td></tr>
    <tr><td class="paramname">duration</td><td>Maximal duration of the motion track in the same units as timestamp .</td></tr>
  </table>
  </dd>
</dl>
<p>The function updates the motion history image as follows:</p>
<p class="formulaDsp">
\[\texttt{mhi} (x,y)= \forkthree{\texttt{timestamp}}{if \(\texttt{silhouette}(x,y) \ne 0\)}{0}{if \(\texttt{silhouette}(x,y) = 0\) and \(\texttt{mhi} &lt; (\texttt{timestamp} - \texttt{duration})\)}{\texttt{mhi}(x,y)}{otherwise}\]
</p>
<p>That is, MHI pixels where the motion occurs are set to the current timestamp , while the pixels where the motion happened last time a long time ago are cleared.</p>
<p>The function, together with calcMotionGradient and calcGlobalOrientation , implements a motion templates technique described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Davis97">[42]</a> and <a class="el" href="../../d0/de3/citelist.html#CITEREF_Bradski00">[24]</a> . </p>
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 18 2018 11:54:27 for OpenCV by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="../../doxygen.png"/>
</a> 1.8.12
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
